<!-- 923760b8-ffc7-41e5-b487-95e4117a17c6 abf55659-e435-4f56-a4bd-15f006cda972 -->
# Ticket + LLM dashboard – high-level implementation plan

## 1. Data model and backend foundations

- Define a `tickets` domain model in the Drizzle schema (`src/server/db/schema.ts`) with fields like: `id`, `externalId`, `provider` (jira/linear/docker/manual), `title`, `description`, `status`, `priority`, `assignee`, `createdAt`, `updatedAt`, `lastSyncedAt`, and any metadata JSON.
- Add related tables for AI features:
- `ticket_recommendations` to store cached recommended steps and recommended programmer per ticket.
- `ticket_messages` to store chat history (`ticketId`, `role`, `content`, `createdAt`) for LLM conversations.
- Optionally a `ticket_rankings` or `ticket_scores` table to persist the latest AI ranking/priority scores per ticket for auditing and reuse.
- Extend the tRPC router (`src/server/api/root.ts`) with a new `ticket` router (e.g. `src/server/api/routers/ticket.ts`) that exposes:
- Queries: list tickets (with filters/pagination), get ticket by id (including recommendations, ranking scores, and chat history).
- Mutations: trigger sync with providers, append a chat message and stream an LLM response, refresh recommendations for a ticket, refresh AI-based ranking for a set of tickets.
- Keep the Better Auth dependency effectively ignored for now: use the existing `protectedProcedure`/protected route pattern, but in development mode short‑circuit auth checks to a mock user so the app is usable without sign‑in; in production, the same code path can be wired back to real Better Auth sessions later.

## 2. Provider integration via strategy pattern

- Design a provider-agnostic interface, e.g. `TicketProvider` in `src/server/tickets/providers/base.ts` with methods like `listTickets`, `getTicket`, and `syncTicketsToDb`.
- Implement concrete strategies:
- `JiraTicketProvider` and `LinearTicketProvider` in `src/server/tickets/providers/jira.ts` and `linear.ts`, using their REST APIs and mapping external fields into the internal `tickets` model.
- A `DockerRepoTicketProvider` stub that will later talk to the Opencode CLI agent (for now, implement the interface but return mocked or empty data).
- Add a `TicketProviderRegistry`/factory (`src/server/tickets/provider-registry.ts`) that resolves a provider by key (`"jira" | "linear" | "docker"`) and encapsulates provider-specific configuration (API base URL, tokens, etc.) pulled from environment variables.
- Implement hybrid sync logic in a `syncTickets` service (`src/server/tickets/sync.ts`):
- Background-style sync function that upserts tickets from all enabled providers into the DB.
- A manual "sync now" function called from a tRPC mutation, which delegates to the same sync logic.

## 3. LLM integration with `ai` SDK, OpenRouter, and Cerebras

- Add the latest `ai` SDK plus the `@ai-sdk/openrouter` and `@ai-sdk/cerebras` providers, and `dedent`, to `package.json` (no code changes until plan approved).
- Create AI service modules, e.g. `src/server/ai/openrouter.ts` and `src/server/ai/cerebras.ts`, that:
- Instantiate the OpenRouter provider using `OPENROUTER_API_KEY` and wire it to the `x-ai/grok-4.1-fast:free` model for summarizing and writing tasks (chatbot replies, recommended steps, recommended programmer).
- Instantiate the Cerebras provider using its API key and configure the `zai-glm-4.6` model for search-style or retrieval/analysis requests (e.g. scanning ticket sets, scoring tickets for ranking, or repo context once the CLI is wired in).
- Expose helpers for `streamText`/`generateText` with properly structured prompts.
- Create a prompt-building utility, e.g. `src/server/ai/prompts.ts`, that uses `dedent` to:
- Build system and user prompts incorporating ticket fields, previous messages, ranking context, and (later) repo context from Opencode.
- Provide specialized prompts for "recommended steps" and "recommended programmer" generation, stored in `ticket_recommendations`.
- Provide specialized prompt shapes for search/analysis and ranking flows that will be routed to the Cerebras `zai-glm-4.6` model.
- Wire these helpers into tRPC procedures in the `ticket` router:
- A streaming chat mutation for the ticket modal chatbot (using Grok via OpenRouter for writing/summarization).
- A mutation to regenerate recommendations on demand (using Grok and caching results in DB to avoid repeated LLM calls).
- A ranking endpoint that calls the Cerebras helper to score and order a set of tickets, optionally persisting scores in `ticket_rankings`.

## 4. UI: dashboard, ranking, and ticket detail modal (shadcn + Tailwind)

- Introduce shadcn UI into the project (using the official generator) and ensure Tailwind is wired for a minimal black/white design (adjust `globals.css` and Tailwind config to use grayscale palette and minimal accents).
- Replace the current landing page in `src/app/page.tsx` with a dashboard layout that is conceptually protected but auto‑accessible in development:
- In production, rely on the protected route pattern (checking auth) to gate access; in development, bypass the check so you can access the dashboard without Better Auth.
- A header with user info (real in prod, mocked in dev) and a "Sync tickets" button that calls the tRPC sync mutation.
- A tickets table/grid component (e.g. `src/app/_components/ticket-table.tsx`) using shadcn `table`, badges, and minimal styling.
- Sorting and ranking controls (e.g. dropdown or segmented control) that let you switch between simple sorts (by date, priority) and an "AI-ranked" view.
- Implement an AI-based ranking flow in the UI:
- Use a tRPC query/mutation that calls the ranker endpoint (Cerebras `zai-glm-4.6`) to score tickets based on urgency, impact, and programmer fit.
- Render tickets ordered by these scores in "AI-ranked" mode, and display a subtle visual indicator (e.g. "AI priority" chip or numeric score) in each row.
- Allow quick filters like "Top N AI-ranked" or "Show only high-priority (score above threshold)".
- Implement a ticket detail modal component (e.g. `src/app/_components/ticket-modal.tsx`) with:
- Ticket metadata (time/date, provider, status, assignee, etc.).
- A "Recommended steps" panel and "Recommended programmer" panel, populated from `ticket_recommendations` and refreshable via button.
- An embedded chat area for LLM interaction, using shadcn inputs/buttons and streaming updates from the tRPC chat mutation.
- Ensure the UI is responsive and keeps to a monochrome, minimal aesthetic while using shadcn components for consistency.

## 5. Chat UI + streaming behavior

- In the client, use the `ai` React utilities (or a light custom hook) to connect the chat box to a streaming endpoint:
- Show token-by-token or chunk-based streaming in the chat area.
- Persist messages to `ticket_messages` after completion via tRPC, so re-opening the modal restores history.
- Add basic error states and loading states ("Connecting to model…", "Syncing tickets…", "Ranking tickets…") using shadcn `toast` or inline status components.

## 6. Docker/CLI + Opencode integration design (stubbed in app)

- Define the contract for the Docker + Opencode integration without fully implementing it yet:
- A `RepoAnalysis` type describing what the CLI will return (e.g. list of files, summaries, potential owners, stack info).
- Service functions in `src/server/tickets/repo-analysis.ts` that are currently mocked or no-ops but match the intended future interface (e.g. `startRepoScan`, `getRepoScanResult`).
- Expose minimal TRPC endpoints to fetch repo analysis data for a ticket, wiring them into the prompt builder as optional context when available.
- Document (in comments and/or README) the expected flow for the future CLI: CLI starts a container, clones the repo, runs Opencode, then pushes results back into the app via an API endpoint or DB.

## 7. Configuration, security, and env handling

- Define and validate all AI-related environment variables (OpenRouter keys/model IDs and Cerebras API key) inside the auth/env configuration file (e.g. an `auth.ts` that already owns Better Auth env validation), so they are strongly typed and verified on startup.
- Add and document required non-AI environment variables in `src/env.js` (and README) for:
- Jira and Linear credentials (URL, project keys, tokens) per user or per environment.
- Ensure all sensitive configuration is server-side only (no exposure in client bundles) and that tRPC procedures validate inputs with `zod`.
- Use Bun consistently for tooling: `bun add` for dependencies, `bun run dev` for local dev, and `bun test` for tests; avoid Node-only tooling/APIs.

## 8. Future text-based ingest (left unimplemented but planned)

- Reserve a place in the architecture for a text-based ingest pipeline:
- Add placeholder types and service stubs (e.g. `TextIngestSource`) that can attach notes or logs to tickets.
- Ensure the data model is flexible enough to add a `source`/`notes` relation later without breaking the UI.

## 9. Testing and polishing

- Add unit tests for the ticket provider strategies (Jira/Linear mapping), ranking helpers, and prompt builder utilities using `bun test` once behavior stabilizes.
- Add a lightweight integration test for the tRPC `ticket` router to confirm list/detail/chat/ranking flows compile and run, including the dev-mode auth bypass behavior.
- Run Biome (`bun run check` or the configured script) to keep the codebase consistent.
- Verify type correctness by running `bun run typecheck` and fixing any TypeScript issues before considering the implementation complete.

### To-dos

- [ ] Extend Drizzle schema with ticket, recommendation, chat message, and optional ranking tables to support the dashboard and LLM features.
- [ ] Create the ticket provider strategy interface and initial Jira/Linear/Docker provider implementations plus sync service.
- [ ] Add a ticket router with list/detail/sync/chat/recommendations/ranking procedures and integrate it into the root tRPC router, keeping auth checks no-op in development.
- [ ] Integrate the ai SDK with OpenRouter and Cerebras (Grok for summarizing/writing, `zai-glm-4.6` for search and ranking) plus dedent-based prompts in server-side helpers and connect them to the ticket router.
- [ ] Implement the dashboard page, ticket table with AI ranking controls, and modal UI using shadcn + Tailwind with a minimal black/white design, treating the route as protected but always accessible in development.
- [ ] Define and stub the Docker/Opencode repo analysis integration so it can later enrich prompts and ticket details without blocking the UI.
- [ ] Add basic tests (including ranking behavior and dev-mode auth bypass), validate env configuration (including AI keys in auth.ts), run Biome, and run `bun run typecheck` to ensure a clean, type-safe codebase.